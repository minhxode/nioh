"use strict";

function _chai() {
  const data = require("chai");

  _chai = function () {
    return data;
  };

  return data;
}

function _packageNameToComponentId() {
  const data = require("./package-name-to-component-id");

  _packageNameToComponentId = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

describe('packageNameToComponentId', function () {
  this.timeout(0);
  let consumer;
  before(() => {
    // @ts-ignore
    consumer = new (_consumer().Consumer)({
      projectPath: '',
      config: {}
    });
  });
  describe('when a packageName has no dots', () => {
    it('should return bitId with no-scope when it is on bitmap', () => {
      // @ts-ignore
      consumer.bitMap = {
        getAllBitIds: () => new (_bitId().BitIds)(new (_bitId().BitId)({
          name: 'foo'
        }))
      };
      const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/foo', '@bit');
      (0, _chai().expect)(result.scope).to.be.null;
      (0, _chai().expect)(result.name).to.equal('foo');
    });
    it('should throw when is not on bitmap', () => {
      // @ts-ignore
      consumer.bitMap = {
        getAllBitIds: () => new (_bitId().BitIds)()
      };

      const func = () => (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/foo', '@bit');

      (0, _chai().expect)(func).to.throw();
    });
  });
  describe('when a packageName has one dot', () => {
    it('should return bitId with no-scope when it is on bitmap this way', () => {
      // @ts-ignore
      consumer.bitMap = {
        getAllBitIds: () => new (_bitId().BitIds)(new (_bitId().BitId)({
          name: 'bar/foo'
        }))
      };
      const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/bar.foo', '@bit');
      (0, _chai().expect)(result.scope).to.be.null;
      (0, _chai().expect)(result.name).to.equal('bar/foo');
    });
    it('should return bitId with scope and name when it is on bitmap this way', () => {
      // @ts-ignore
      consumer.bitMap = {
        getAllBitIds: () => new (_bitId().BitIds)(new (_bitId().BitId)({
          scope: 'bar',
          name: 'foo'
        }))
      };
      const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/bar.foo', '@bit');
      (0, _chai().expect)(result.scope).to.equal('bar');
      (0, _chai().expect)(result.name).to.equal('foo');
    });
    it('should return bitId with scope and name when it is not on bitmap as it cannot be new component', () => {
      // @ts-ignore
      consumer.bitMap = {
        getAllBitIds: () => new (_bitId().BitIds)()
      };
      const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/bar.foo', '@bit');
      (0, _chai().expect)(result.scope).to.equal('bar');
      (0, _chai().expect)(result.name).to.equal('foo');
    });
  });
  describe('when a packageName has two dots', () => {
    it('should return bitId with no-scope when it is on bitmap this way', () => {
      // @ts-ignore
      consumer.bitMap = {
        getAllBitIds: () => new (_bitId().BitIds)(new (_bitId().BitId)({
          name: 'foo/bar/qux'
        }))
      };
      const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/foo.bar.qux', '@bit');
      (0, _chai().expect)(result.scope).to.be.null;
      (0, _chai().expect)(result.name).to.equal('foo/bar/qux');
    });
    it('should return bitId with scope without dot and name when it is on bitmap this way', () => {
      // @ts-ignore
      consumer.bitMap = {
        getAllBitIds: () => new (_bitId().BitIds)(new (_bitId().BitId)({
          scope: 'foo',
          name: 'bar/qux'
        }))
      };
      const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/foo.bar.qux', '@bit');
      (0, _chai().expect)(result.scope).to.equal('foo');
      (0, _chai().expect)(result.name).to.equal('bar/qux');
    });
    it('should return bitId with scope with dot and name when it is on bitmap this way', () => {
      // @ts-ignore
      consumer.bitMap = {
        getAllBitIds: () => new (_bitId().BitIds)(new (_bitId().BitId)({
          scope: 'foo.bar',
          name: 'qux'
        }))
      };
      const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/foo.bar.qux', '@bit');
      (0, _chai().expect)(result.scope).to.equal('foo.bar');
      (0, _chai().expect)(result.name).to.equal('qux');
    });
    it('should return bitId with scope with dot and name when it is not on bitmap', () => {
      // @ts-ignore
      consumer.bitMap = {
        getAllBitIds: () => new (_bitId().BitIds)()
      };
      const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/foo.bar.qux', '@bit');
      (0, _chai().expect)(result.scope).to.equal('foo.bar');
      (0, _chai().expect)(result.name).to.equal('qux');
    });
  });
  it('should parse the path correctly when a component is not in bitMap and has one dot', () => {
    const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/remote.comp', '@bit');
    (0, _chai().expect)(result.scope).to.equal('remote');
    (0, _chai().expect)(result.name).to.equal('comp');
  });
  it('should parse the path correctly when a component is not in bitMap and has two dots', () => {
    const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/remote.comp.comp2', '@bit');
    (0, _chai().expect)(result.scope).to.equal('remote.comp');
    (0, _chai().expect)(result.name).to.equal('comp2');
  });
  it('should parse the path correctly when a component is not in bitMap and has three dots', () => {
    const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/remote.comp.comp2.comp3', '@bit');
    (0, _chai().expect)(result.scope).to.equal('remote.comp');
    (0, _chai().expect)(result.name).to.equal('comp2/comp3');
  });
  describe('with defaultScope', () => {
    describe('when the defaultScope has dot', () => {
      it('should return bitId without scope when the component is in .bitmap without scope', () => {
        // @ts-ignore
        consumer.bitMap = {
          getAllBitIds: () => new (_bitId().BitIds)(new (_bitId().BitId)({
            name: 'bar/foo'
          }))
        };
        consumer.config.defaultScope = 'bit.utils';
        const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/bit.utils.bar.foo', '@bit');
        (0, _chai().expect)(result.scope).to.be.null;
        (0, _chai().expect)(result.name).to.equal('bar/foo');
      });
      it('should return bitId with scope when the component is in .bitmap with scope', () => {
        // @ts-ignore
        consumer.bitMap = {
          getAllBitIds: () => new (_bitId().BitIds)(new (_bitId().BitId)({
            scope: 'bit.utils',
            name: 'bar/foo'
          }))
        };
        consumer.config.defaultScope = 'bit.utils';
        const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/bit.utils.bar.foo', '@bit');
        (0, _chai().expect)(result.scope).to.equal('bit.utils');
        (0, _chai().expect)(result.name).to.equal('bar/foo');
      });
      it('should return bitId with scope when the component is not .bitmap at all', () => {
        // @ts-ignore
        consumer.bitMap = {
          getAllBitIds: () => new (_bitId().BitIds)()
        };
        consumer.config.defaultScope = 'bit.utils';
        const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/bit.utils.bar.foo', '@bit');
        (0, _chai().expect)(result.scope).to.equal('bit.utils');
        (0, _chai().expect)(result.name).to.equal('bar/foo');
      });
    });
    describe('when the defaultScope does not have dot', () => {
      before(() => {
        consumer.config.defaultScope = 'utils';
      });
      it('should return bitId without scope when the component is in .bitmap without scope', () => {
        // @ts-ignore
        consumer.bitMap = {
          getAllBitIds: () => new (_bitId().BitIds)(new (_bitId().BitId)({
            name: 'bar/foo'
          }))
        };
        const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/utils.bar.foo', '@bit');
        (0, _chai().expect)(result.scope).to.be.null;
        (0, _chai().expect)(result.name).to.equal('bar/foo');
      });
      it('should return bitId with scope when the component is in .bitmap with scope', () => {
        // @ts-ignore
        consumer.bitMap = {
          getAllBitIds: () => new (_bitId().BitIds)(new (_bitId().BitId)({
            scope: 'utils',
            name: 'bar/foo'
          }))
        };
        const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/utils.bar.foo', '@bit');
        (0, _chai().expect)(result.scope).to.equal('utils');
        (0, _chai().expect)(result.name).to.equal('bar/foo');
      });
      it('should return bitId with scope when the component is not .bitmap at all', () => {
        // @ts-ignore
        consumer.bitMap = {
          getAllBitIds: () => new (_bitId().BitIds)()
        };
        const result = (0, _packageNameToComponentId().packageNameToComponentId)(consumer, '@bit/utils.bar.foo', '@bit'); // looks weird, but the default is a dot in the scope.

        (0, _chai().expect)(result.scope).to.equal('utils.bar');
        (0, _chai().expect)(result.name).to.equal('foo');
      });
    });
  });
});