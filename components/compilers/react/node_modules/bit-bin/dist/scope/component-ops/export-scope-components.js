"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exportManyBareScope = exportManyBareScope;
exports.exportMany = exportMany;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _graphlib() {
  const data = _interopRequireDefault(require("graphlib"));

  _graphlib = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _enrichContextFromGlobal() {
  const data = _interopRequireDefault(require("../../hooks/utils/enrich-context-from-global"));

  _enrichContextFromGlobal = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("../exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _componentObjects() {
  const data = _interopRequireDefault(require("../component-objects"));

  _componentObjects = function () {
    return data;
  };

  return data;
}

function _objects() {
  const data = require("../objects");

  _objects = function () {
    return data;
  };

  return data;
}

function _models() {
  const data = require("../models");

  _models = function () {
    return data;
  };

  return data;
}

function _scopeRemotes() {
  const data = require("../scope-remotes");

  _scopeRemotes = function () {
    return data;
  };

  return data;
}

function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("./scope-components-importer"));

  _scopeComponentsImporter = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../../utils/bit/component-id-to-package-name"));

  _componentIdToPackageName = function () {
    return data;
  };

  return data;
}

function _source() {
  const data = _interopRequireDefault(require("../models/source"));

  _source = function () {
    return data;
  };

  return data;
}

function _componentsGraph() {
  const data = require("../graph/components-graph");

  _componentsGraph = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _replacePackageName() {
  const data = _interopRequireDefault(require("../../utils/string/replace-package-name"));

  _replacePackageName = function () {
    return data;
  };

  return data;
}

/**
 * @TODO there is no real difference between bare scope and a working directory scope - let's adjust terminology to avoid confusions in the future
 * saves a component into the objects directory of the remote scope, then, resolves its
 * dependencies, saves them as well. Finally runs the build process if needed on an isolated
 * environment.
 */
function exportManyBareScope(_x, _x2, _x3) {
  return _exportManyBareScope.apply(this, arguments);
}

function _exportManyBareScope() {
  _exportManyBareScope = (0, _bluebird().coroutine)(function* (scope, componentsObjects, clientIsOld) {
    _logger().default.debugAndAddBreadCrumb('scope.exportManyBareScope', `Going to save ${componentsObjects.length} components`);

    const manyObjects = componentsObjects.map(componentObjects => componentObjects.toObjects(scope.objects));
    const mergedIds = yield mergeObjects(scope, manyObjects);

    _logger().default.debugAndAddBreadCrumb('exportManyBareScope', 'will try to importMany in case there are missing dependencies');

    const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(scope);

    yield scopeComponentsImporter.importMany(mergedIds, true, false); // resolve dependencies

    _logger().default.debugAndAddBreadCrumb('exportManyBareScope', 'successfully ran importMany');

    yield scope.objects.persist();

    _logger().default.debugAndAddBreadCrumb('exportManyBareScope', 'objects were written successfully to the filesystem'); // @todo: this is a temp workaround, remove once v15 is out


    if (clientIsOld) {
      const manyCompVersions = manyObjects.map(objects => objects.component.toComponentVersion(_constants().LATEST));

      const bitIds = _bitId().BitIds.fromArray(manyCompVersions.map(compVersion => compVersion.id));

      _logger().default.debug('exportManyBareScope: completed. exit.');

      return bitIds;
    }

    _logger().default.debug('exportManyBareScope: completed. exit.');

    return mergedIds;
  });
  return _exportManyBareScope.apply(this, arguments);
}

function exportMany(_x4) {
  return _exportMany.apply(this, arguments);
}
/**
 * merge components into the scope.
 *
 * a component might have multiple versions that some where merged and some were not.
 * the BitIds returned here includes the versions that were merged. so it could contain multiple
 * ids of the same component with different versions
 */


function _exportMany() {
  _exportMany = (0, _bluebird().coroutine)(function* ({
    scope,
    ids,
    remoteName,
    context = {},
    includeDependencies = false,
    // kind of fork. by default dependencies only cached, with this, their scope-name is changed
    changeLocallyAlthoughRemoteIsDifferent = false,
    // by default only if remote stays the same the component is changed from staged to exported
    codemod = false,
    allVersions,
    idsWithFutureScope
  }) {
    _logger().default.debugAndAddBreadCrumb('scope.exportMany', 'ids: {ids}', {
      ids: ids.toString()
    });

    (0, _enrichContextFromGlobal().default)(context);

    if (includeDependencies) {
      const dependenciesIds = yield getDependenciesImportIfNeeded();
      ids.push(...dependenciesIds);
      ids = _bitId().BitIds.uniqFromArray(ids);
    }

    const remotes = yield (0, _scopeRemotes().getScopeRemotes)(scope);

    if (remoteName) {
      _logger().default.debugAndAddBreadCrumb('export-scope-components', 'export all ids to one remote');

      return exportIntoRemote(remoteName, ids);
    }

    _logger().default.debugAndAddBreadCrumb('export-scope-components', 'export ids to multiple remotes');

    const groupedByScope = yield sortAndGroupByScope();
    const groupedByScopeString = groupedByScope.map(item => `scope "${item.scopeName}": ${item.ids.toString()}`).join(', ');

    _logger().default.debug(`export-scope-components, export to the following scopes ${groupedByScopeString}`);

    const results = yield (0, _pMapSeries().default)(groupedByScope, result => exportIntoRemote(result.scopeName, result.ids));
    return {
      exported: _bitId().BitIds.uniqFromArray(_ramda().default.flatten(results.map(r => r.exported))),
      updatedLocally: _bitId().BitIds.uniqFromArray(_ramda().default.flatten(results.map(r => r.updatedLocally)))
    };

    function exportIntoRemote(_x16, _x17) {
      return _exportIntoRemote.apply(this, arguments);
    }
    /**
     * the topological sort is needed in case components have dependencies in other scopes.
     * without sorting, in case remoteA/compA depends on remoteB/compB and remoteA/compA was exported
     * first, remoteA will throw an error that remoteB/compB was not found.
     * sorting the components topologically, ensure we export remoteB/compB first.
     *
     * there are a few cases to consider:
     * 1) in case there are cycle dependencies between the scopes, it's impossible to toposort.
     * 2) the cycle dependencies can be between different versions. e.g. remoteA/compA@0.0.1 requires
     * remoteB/compB@0.0.1 and remoteB/compB@0.0.2 requires remoteA/compA@0.0.2.
     * that's why when building the graph we take all versions into account and build the graph
     * without the version number, so then we could let the graph's algorithm finding the cycle.
     * 3) it's possible to have circle dependencies inside the same scope, and non-circle
     * dependencies between the different scopes. in this case, the toposort should be done after
     * removing the ids participated in the circular.
     *
     * once the sort is done, it returns an array of { scopeName: string; ids: BitIds }.
     * keep in mind that this array might have multiple items with the same scopeName, that's totally
     * valid and it will cause multiple round-trip to the same scope. there is no other way around
     * it.
     * the sort is done after eliminating circles, so it's possible to execute topsort. once the
     * components are topological sorted, they are added one by one to the results array. If the last
     * item in the array has the same scope as the currently inserted component, it can be added to
     * the same scope group. otherwise, a new item needs to be added to the array with the new scope.
     */


    function _exportIntoRemote() {
      _exportIntoRemote = (0, _bluebird().coroutine)(function* (remoteNameStr, bitIds) {
        const remote = yield remotes.resolve(remoteNameStr, scope);
        const componentObjects = yield (0, _pMapSeries().default)(bitIds, id => scope.sources.getObjects(id));

        const idsToChangeLocally = _bitId().BitIds.fromArray(bitIds.filter(id => !id.scope || id.scope === remoteNameStr || changeLocallyAlthoughRemoteIsDifferent));

        const componentsAndObjects = [];

        const processComponentObjects =
        /*#__PURE__*/
        function () {
          var _ref = (0, _bluebird().coroutine)(function* (componentObject) {
            const componentAndObject = componentObject.toObjects(scope.objects);
            const localVersions = componentAndObject.component.getLocalVersions();
            componentAndObject.component.clearStateData();
            const didConvertScope = yield convertToCorrectScope(scope, componentAndObject, remoteNameStr, includeDependencies, bitIds, codemod);
            const didChangeDists = yield changePartialNamesToFullNamesInDists(scope, componentAndObject.component, componentAndObject.objects);
            const remoteObj = {
              url: remote.host,
              name: remote.name,
              date: Date.now().toString()
            };
            componentAndObject.component.addScopeListItem(remoteObj);

            if (idsToChangeLocally.hasWithoutScopeAndVersion(componentAndObject.component.toBitId())) {
              // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
              componentsAndObjects.push(componentAndObject);
            } else {
              // the component should not be changed locally. only add the new scope to the scope-list
              const componentAndObjectCloned = componentObject.toObjects(scope.objects);
              componentAndObjectCloned.component.addScopeListItem(remoteObj); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

              componentsAndObjects.push(componentAndObjectCloned);
            }

            const componentBuffer = yield componentAndObject.component.compress();

            const getObjectsBuffer = () => {
              if (allVersions || includeDependencies || didConvertScope || didChangeDists) {
                // only when really needed (e.g. fork or version changes), collect all versions objects
                return Promise.all(componentAndObject.objects.map(obj => obj.compress()));
              } // when possible prefer collecting only new/local versions. the server has already
              // the rest, so no point of sending them.


              return componentAndObject.component.collectVersionsObjects(scope.objects, localVersions);
            };

            const objectsBuffer = yield getObjectsBuffer();
            return new (_componentObjects().default)(componentBuffer, objectsBuffer);
          });

          return function processComponentObjects(_x18) {
            return _ref.apply(this, arguments);
          };
        }(); // don't use Promise.all, otherwise, it'll throw "JavaScript heap out of memory" on a large set of data


        const manyObjects = yield (0, _pMapSeries().default)(componentObjects, processComponentObjects);
        let exportedIds;

        try {
          exportedIds = yield remote.pushMany(manyObjects, context);

          _logger().default.debugAndAddBreadCrumb('exportMany', 'successfully pushed all ids to the bare-scope, going to save them back to local scope');
        } catch (err) {
          _logger().default.warnAndAddBreadCrumb('exportMany', 'failed pushing ids to the bare-scope');

          return Promise.reject(err);
        }

        yield Promise.all(idsToChangeLocally.map(id => scope.sources.removeComponentById(id))); // @ts-ignore

        idsToChangeLocally.forEach(id => scope.createSymlink(id, remoteNameStr));
        componentsAndObjects.forEach(componentObject => scope.sources.put(componentObject));
        yield scope.objects.persist(); // remove version. exported component might have multiple versions exported

        const idsWithRemoteScope = exportedIds.map(id => _bitId().BitId.parse(id, true).changeVersion(null));

        const idsWithRemoteScopeUniq = _bitId().BitIds.uniqFromArray(idsWithRemoteScope);

        return {
          exported: idsWithRemoteScopeUniq,
          updatedLocally: _bitId().BitIds.fromArray(idsWithRemoteScopeUniq.filter(id => idsToChangeLocally.hasWithoutScopeAndVersion(id)))
        };
      });
      return _exportIntoRemote.apply(this, arguments);
    }

    function sortAndGroupByScope() {
      return _sortAndGroupByScope.apply(this, arguments);
    }

    function _sortAndGroupByScope() {
      _sortAndGroupByScope = (0, _bluebird().coroutine)(function* () {
        const grouped = ids.toGroupByScopeName(idsWithFutureScope);
        const groupedArrayFormat = Object.keys(grouped).map(scopeName => ({
          scopeName,
          ids: grouped[scopeName]
        }));

        if (Object.keys(grouped).length <= 1) {
          return groupedArrayFormat;
        } // when exporting to multiple scopes, there is a chance of dependencies between the different scopes


        const componentsAndVersions = yield scope.getComponentsAndAllLocalUnexportedVersions(ids);
        const graph = (0, _componentsGraph().buildOneGraphForComponentsAndMultipleVersions)(componentsAndVersions);

        const cycles = _graphlib().default.alg.findCycles(graph);

        const groupedArraySorted = [];

        const addToGroupedSorted = id => {
          if (groupedArraySorted.length) {
            const lastItem = groupedArraySorted[groupedArraySorted.length - 1];

            if (lastItem.scopeName === id.scope) {
              lastItem.ids.push(id);
              return;
            }
          }

          const idWithFutureScope = idsWithFutureScope.searchWithoutScopeAndVersion(id);

          if (idWithFutureScope) {
            groupedArraySorted.push({
              scopeName: idWithFutureScope.scope,
              ids: new (_bitId().BitIds)(id)
            });
          } // otherwise, it's in the graph, but not in the idWithFutureScope array. this is probably just a
          // dependency of one of the pending-export ids, and that dependency is not supposed to be
          // export, so just ignore it.

        };

        if (cycles.length) {
          const cyclesWithMultipleScopes = cycles.filter(cycle => {
            const bitIds = cycle.map(s => graph.node(s));
            const firstScope = bitIds[0].scope;
            return bitIds.some(id => id.scope !== firstScope);
          });

          if (cyclesWithMultipleScopes.length) {
            throw new (_generalError().default)(`fatal: unable to export. the following components have circular dependencies between two or more scopes
${cyclesWithMultipleScopes.map(c => c.join(', ')).join('\n')}
please untag the problematic components and eliminate the circle between the scopes.
tip: use "bit graph [--all-versions]" to get a visual look of the circular dependencies`);
          } // there are circles but they are all from the same scope, add them to groupedArraySorted
          // first, then, remove from the graph, so it will be possible to execute topsort


          cycles.forEach(cycle => {
            cycle.forEach(node => {
              const id = graph.node(node);
              addToGroupedSorted(id);
              graph.removeNode(node);
            });
          });
        } // @todo: optimize in case each one of the ids has all its dependencies from the same scope,
        // return groupedArrayFormat


        let sortedComponents;

        try {
          sortedComponents = _graphlib().default.alg.topsort(graph);
        } catch (err) {
          // should never arrive here, it's just a precaution, as topsort doesn't fail nicely
          _logger().default.error(err);

          throw new Error(`fatal: graphlib was unable to topsort the components. circles: ${cycles}`);
        }

        const sortedComponentsIds = sortedComponents.map(s => graph.node(s)).reverse();
        sortedComponentsIds.forEach(id => addToGroupedSorted(id));
        return groupedArraySorted;
      });
      return _sortAndGroupByScope.apply(this, arguments);
    }

    function getDependenciesImportIfNeeded() {
      return _getDependenciesImportIfNeeded.apply(this, arguments);
    }

    function _getDependenciesImportIfNeeded() {
      _getDependenciesImportIfNeeded = (0, _bluebird().coroutine)(function* () {
        const scopeComponentImporter = new (_scopeComponentsImporter().default)(scope);
        const versionsDependencies = yield scopeComponentImporter.importManyWithAllVersions(ids, true, true);

        const allDependencies = _ramda().default.flatten(versionsDependencies.map(versionDependencies => versionDependencies.allDependencies));

        return allDependencies.map(componentVersion => componentVersion.component.toBitId());
      });
      return _getDependenciesImportIfNeeded.apply(this, arguments);
    }
  });
  return _exportMany.apply(this, arguments);
}

function mergeObjects(_x5, _x6) {
  return _mergeObjects.apply(this, arguments);
}
/**
 * When exporting components with dependencies to a bare-scope, some of the dependencies may be created locally and as
 * a result their scope-name is null. Once the bare-scope gets the components, it needs to convert these scope names
 * to the bare-scope name.
 * Since the changes it does affect the Version objects, the version REF of a component, needs to be changed as well.
 */


function _mergeObjects() {
  _mergeObjects = (0, _bluebird().coroutine)(function* (scope, manyObjects) {
    const mergeResults = yield Promise.all(manyObjects.map(
    /*#__PURE__*/
    function () {
      var _ref2 = (0, _bluebird().coroutine)(function* (objects) {
        try {
          const result = yield scope.sources.merge(objects, true, false);
          return result;
        } catch (err) {
          if (err instanceof _exceptions().MergeConflict) {
            return err; // don't throw. instead, get all components with merge-conflicts
          }

          throw err;
        }
      });

      return function (_x19) {
        return _ref2.apply(this, arguments);
      };
    }()));
    const componentsWithConflicts = mergeResults.filter(result => result instanceof _exceptions().MergeConflict);

    if (componentsWithConflicts.length) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const idsAndVersions = componentsWithConflicts.map(c => ({
        id: c.id,
        versions: c.versions
      })); // sort to have a consistent error message

      const idsAndVersionsSorted = _ramda().default.sortBy(_ramda().default.prop('id'), idsAndVersions);

      throw new (_exceptions().MergeConflictOnRemote)(idsAndVersionsSorted);
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    const mergedComponents = mergeResults.filter(({
      mergedVersions
    }) => mergedVersions.length);

    const getMergedIds = ({
      mergedComponent,
      mergedVersions
    }) => mergedVersions.map(version => mergedComponent.toBitId().changeVersion(version)); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    return _bitId().BitIds.fromArray(_ramda().default.flatten(mergedComponents.map(getMergedIds)));
  });
  return _mergeObjects.apply(this, arguments);
}

function convertToCorrectScope(_x7, _x8, _x9, _x10, _x11, _x12) {
  return _convertToCorrectScope.apply(this, arguments);
}
/**
 * see https://github.com/teambit/bit/issues/1770 for complete info
 * some compilers require the links to be part of the bundle, change the component name in these
 * files from the id without scope to the id with the scope
 * e.g. `@bit/utils.is-string` becomes `@bit/scope-name.utils.is-string`
 */


function _convertToCorrectScope() {
  _convertToCorrectScope = (0, _bluebird().coroutine)(function* (scope, componentsObjects, remoteScope, fork, exportingIds, codemod) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const versionsObjects = componentsObjects.objects.filter(object => object instanceof _models().Version);
    const haveVersionsChanged = yield Promise.all(versionsObjects.map(
    /*#__PURE__*/
    function () {
      var _ref3 = (0, _bluebird().coroutine)(function* (objectVersion) {
        const hashBefore = objectVersion.hash().toString();
        const didCodeMod = codemod ? yield _replaceSrcOfVersionIfNeeded(objectVersion) : false;
        const didDependencyChange = changeDependencyScope(objectVersion);
        const hashAfter = objectVersion.hash().toString();

        if (hashBefore !== hashAfter) {
          if (!didCodeMod && !didDependencyChange) {
            throw new Error('hash should not be changed if there was not any dependency scope changes nor codemod');
          }

          _logger().default.debugAndAddBreadCrumb('scope._convertToCorrectScope', `switching {id} version hash from ${hashBefore} to ${hashAfter}`, {
            id: componentsObjects.component.id().toString()
          });

          const versions = componentsObjects.component.versions;
          Object.keys(versions).forEach(version => {
            if (versions[version].toString() === hashBefore) {
              versions[version] = _objects().Ref.from(hashAfter);
            }
          });
        }

        return didCodeMod || didDependencyChange;
      });

      return function (_x20) {
        return _ref3.apply(this, arguments);
      };
    }()));
    const hasComponentChanged = remoteScope !== componentsObjects.component.scope;
    componentsObjects.component.scope = remoteScope; // return true if one of the versions has changed or the component itself

    return haveVersionsChanged.some(x => x) || hasComponentChanged;

    function changeDependencyScope(version) {
      let hasChanged = false;
      version.getAllDependencies().forEach(dependency => {
        const updatedScope = getIdWithUpdatedScope(dependency.id);

        if (!updatedScope.isEqual(dependency.id)) {
          hasChanged = true;
          dependency.id = updatedScope;
        }
      });
      version.flattenedDependencies = getBitIdsWithUpdatedScope(version.flattenedDependencies);
      version.flattenedDevDependencies = getBitIdsWithUpdatedScope(version.flattenedDevDependencies);
      version.flattenedCompilerDependencies = getBitIdsWithUpdatedScope(version.flattenedCompilerDependencies);
      version.flattenedTesterDependencies = getBitIdsWithUpdatedScope(version.flattenedTesterDependencies);
      return hasChanged;
    }

    function getIdWithUpdatedScope(dependencyId) {
      if (dependencyId.scope === remoteScope) {
        return dependencyId; // nothing has changed
      }

      if (!dependencyId.scope || fork || exportingIds.hasWithoutVersion(dependencyId)) {
        const depId = _models().ModelComponent.fromBitId(dependencyId); // todo: use 'load' for async and switch the foreach with map.


        const dependencyObject = scope.objects.loadSync(depId.hash());

        if (dependencyObject instanceof _models().Symlink) {
          return dependencyId.changeScope(dependencyObject.realScope);
        }

        return dependencyId.changeScope(remoteScope);
      }

      return dependencyId;
    }

    function getBitIdsWithUpdatedScope(bitIds) {
      const updatedIds = bitIds.map(id => getIdWithUpdatedScope(id));
      return _bitId().BitIds.fromArray(updatedIds);
    }

    function _replaceSrcOfVersionIfNeeded(_x21) {
      return _replaceSrcOfVersionIfNeeded2.apply(this, arguments);
    }

    function _replaceSrcOfVersionIfNeeded2() {
      _replaceSrcOfVersionIfNeeded2 = (0, _bluebird().coroutine)(function* (version) {
        let hasVersionChanged = false;
        const files = [...version.files, ...(version.dists || [])];
        yield Promise.all(files.map(
        /*#__PURE__*/
        function () {
          var _ref4 = (0, _bluebird().coroutine)(function* (file) {
            const newFileObject = yield _createNewFileIfNeeded(version, file);

            if (newFileObject) {
              file.file = newFileObject.hash();
              componentsObjects.objects.push(newFileObject);
              hasVersionChanged = true;
            }

            return null;
          });

          return function (_x24) {
            return _ref4.apply(this, arguments);
          };
        }()));
        return hasVersionChanged;
      });
      return _replaceSrcOfVersionIfNeeded2.apply(this, arguments);
    }

    function _createNewFileIfNeeded(_x22, _x23) {
      return _createNewFileIfNeeded2.apply(this, arguments);
    }

    function _createNewFileIfNeeded2() {
      _createNewFileIfNeeded2 = (0, _bluebird().coroutine)(function* (version, file) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        const currentHash = file.file; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        const fileObject = yield scope.objects.load(currentHash);
        const fileString = fileObject.contents.toString();
        const dependenciesIds = version.getAllDependencies().map(d => d.id);
        const allIds = [...dependenciesIds, componentsObjects.component.toBitId()];
        let newFileString = fileString;
        allIds.forEach(id => {
          if (id.scope === remoteScope) {
            return; // nothing to do, the remote has not changed
          }

          const idWithNewScope = id.changeScope(remoteScope);
          const pkgNameWithNewScope = (0, _componentIdToPackageName().default)(idWithNewScope, componentsObjects.component.bindingPrefix);
          const pkgNameWithOldScope = (0, _componentIdToPackageName().default)(id, componentsObjects.component.bindingPrefix); // replace an exact match. (e.g. '@bit/old-scope.is-string' => '@bit/new-scope.is-string')
          // the require/import statement might be to an internal path (e.g. '@bit/david.utils/is-string/internal-file')

          newFileString = (0, _replacePackageName().default)(newFileString, pkgNameWithOldScope, pkgNameWithNewScope);
        });

        if (newFileString !== fileString) {
          return _source().default.from(Buffer.from(newFileString));
        }

        return null;
      });
      return _createNewFileIfNeeded2.apply(this, arguments);
    }
  });
  return _convertToCorrectScope.apply(this, arguments);
}

function changePartialNamesToFullNamesInDists(_x13, _x14, _x15) {
  return _changePartialNamesToFullNamesInDists.apply(this, arguments);
}

function _changePartialNamesToFullNamesInDists() {
  _changePartialNamesToFullNamesInDists = (0, _bluebird().coroutine)(function* (scope, component, objects) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const versions = objects.filter(object => object instanceof _models().Version);
    const haveVersionsChanged = yield Promise.all(versions.map(version => _replaceDistsOfVersionIfNeeded(version)));
    return haveVersionsChanged.some(x => x);

    function _replaceDistsOfVersionIfNeeded(_x25) {
      return _replaceDistsOfVersionIfNeeded2.apply(this, arguments);
    }

    function _replaceDistsOfVersionIfNeeded2() {
      _replaceDistsOfVersionIfNeeded2 = (0, _bluebird().coroutine)(function* (version) {
        const dists = version.dists;
        if (!dists) return false;
        const hasDistsChanged = yield Promise.all(dists.map(
        /*#__PURE__*/
        function () {
          var _ref5 = (0, _bluebird().coroutine)(function* (dist) {
            const newDistObject = yield _createNewDistIfNeeded(version, dist);

            if (newDistObject) {
              dist.file = newDistObject.hash();
              objects.push(newDistObject);
              return true;
            }

            return false;
          });

          return function (_x28) {
            return _ref5.apply(this, arguments);
          };
        }())); // return true if one of the dists has changed

        return hasDistsChanged.some(x => x);
      });
      return _replaceDistsOfVersionIfNeeded2.apply(this, arguments);
    }

    function _createNewDistIfNeeded(_x26, _x27) {
      return _createNewDistIfNeeded2.apply(this, arguments);
    }

    function _createNewDistIfNeeded2() {
      _createNewDistIfNeeded2 = (0, _bluebird().coroutine)(function* (version, dist) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        const currentHash = dist.file; // if a dist file has changed as a result of codemod, it's not on the fs yet, so we fallback
        // to load from the objects it was pushed before. it'd be better to have more efficient mechanism.
        // currently, we require calculating the hash for each one of the source every time.

        const distObject = (yield currentHash.load(scope.objects)) || objects.filter(obj => obj instanceof _source().default).find(obj => obj.hash().toString() === currentHash.toString());
        const distString = distObject.contents.toString();
        const dependenciesIds = version.getAllDependencies().map(d => d.id);
        const allIds = [...dependenciesIds, component.toBitId()];
        let newDistString = distString;
        allIds.forEach(id => {
          const idWithoutScope = id.changeScope(null);
          const pkgNameWithoutScope = (0, _componentIdToPackageName().default)(idWithoutScope, component.bindingPrefix);
          const pkgNameWithScope = (0, _componentIdToPackageName().default)(id, component.bindingPrefix); // replace an exact match. (e.g. '@bit/is-string' => '@bit/david.utils/is-string')
          // the require/import statement might be to an internal path (e.g. '@bit/david.utils/is-string/internal-file')

          newDistString = (0, _replacePackageName().default)(newDistString, pkgNameWithoutScope, pkgNameWithScope);
        });

        if (newDistString !== distString) {
          return _source().default.from(Buffer.from(newDistString));
        }

        return null;
      });
      return _createNewDistIfNeeded2.apply(this, arguments);
    }
  });
  return _changePartialNamesToFullNamesInDists.apply(this, arguments);
}