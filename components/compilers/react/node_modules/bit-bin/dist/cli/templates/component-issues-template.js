"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInvalidComponentLabel = getInvalidComponentLabel;
exports.componentIssueToString = componentIssueToString;
exports.untrackedFilesComponentIssueToString = untrackedFilesComponentIssueToString;
exports.default = componentIssuesTemplate;
exports.formatMissing = formatMissing;
exports.MISSING_PACKAGES_FROM_OVERRIDES_LABEL = exports.componentIssuesLabels = void 0;

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

const componentIssuesLabels = {
  missingPackagesDependenciesOnFs: 'missing packages dependencies (use your package manager to make sure all package dependencies are installed)',
  missingComponents: 'missing components (use "bit import" or your package manager to make sure all components are installed)',
  untrackedDependencies: 'untracked file dependencies (use "bit add <file>" to track untracked files as components)',
  missingDependenciesOnFs: 'non-existing dependency files (please make sure all files exists on your workspace)',
  missingLinks: 'missing links (use "bit link" to build missing component links)',
  missingCustomModuleResolutionLinks: 'missing links (use "bit link" to build missing component links)',
  relativeComponents: 'components with relative import statements (please use absolute paths for imported components)',
  parseErrors: 'error found while parsing the file (please edit the file and fix the parsing error)',
  resolveErrors: 'error found while resolving the file dependencies (see the log for the full error)'
};
exports.componentIssuesLabels = componentIssuesLabels;
const MISSING_PACKAGES_FROM_OVERRIDES_LABEL = 'from overrides configuration';
exports.MISSING_PACKAGES_FROM_OVERRIDES_LABEL = MISSING_PACKAGES_FROM_OVERRIDES_LABEL;

function getInvalidComponentLabel(error) {
  switch (error.name) {
    case 'MainFileRemoved':
      return 'main-file was removed (use "bit add" with "--main" and "--id" flags to add a main file)';

    case 'MissingFilesFromComponent':
    case 'ComponentNotFoundInPath':
      return 'component files were deleted (use "bit remove [component_id]" or "bit untrack [component_id]" to remove the component from your workspace)';

    case 'ExtensionFileNotFound':
      // $FlowFixMe error.path is set for ExtensionFileNotFound
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return `extension file is missing at ${_chalk().default.bold(error.path)}`;

    case 'ComponentsPendingImport':
      return 'component objects are missing from the scope (use "bit import [component_id] --objects" to get them back)';

    default:
      return error.name;
  }
}

function componentIssueToString(value) {
  return Array.isArray(value) ? value.join(', ') : value;
}

function untrackedFilesComponentIssueToString(value) {
  const colorizedMap = value.untrackedFiles.map(curr => {
    if (curr.existing) {
      return `${_chalk().default.yellow(curr.relativePath)}`;
    }

    return curr.relativePath;
  });
  return colorizedMap.join(', ');
}

function componentIssuesTemplate(components) {
  function format(missingComponent) {
    return `${_chalk().default.underline(_chalk().default.cyan(missingComponent.id.toString()))}\n${formatMissing(missingComponent)}`;
  }

  const result = `\n${components.map(format).join('\n')}`;
  return result;
}

function formatMissing(missingComponent) {
  function formatMissingStr(key, value, label, formatIssueFunc = componentIssueToString) {
    if (!value || _ramda().default.isEmpty(value)) return '';
    return _chalk().default.yellow(`\n       ${label}: \n`) + _chalk().default.white(Object.keys(value).map(k => {
      let space = _constants().MISSING_DEPS_SPACE;

      if (value[k].nested) {
        space = _constants().MISSING_NESTED_DEPS_SPACE;
      }

      return `${space}${k} -> ${formatIssueFunc(value[k])}`;
    }).join('\n'));
  }

  const missingStr = Object.keys(componentIssuesLabels).map(key => {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (missingComponent.issues[key]) _analytics().Analytics.incExtraDataKey(key);

    if (key === 'untrackedDependencies') {
      // @ts-ignore
      return formatMissingStr(key, missingComponent.issues[key], componentIssuesLabels[key], untrackedFilesComponentIssueToString);
    }

    if (key === 'missingPackagesDependenciesOnFs') {
      // Combine missing from files and missing from packages (for output only)
      const missingPackagesDependenciesOnFs = missingComponent.issues[key] || {};
      const missingPackagesDependenciesFromOverrides = // @ts-ignore
      missingComponent.issues.missingPackagesDependenciesFromOverrides || [];

      if (!_ramda().default.isEmpty(missingPackagesDependenciesFromOverrides)) {
        missingPackagesDependenciesOnFs[MISSING_PACKAGES_FROM_OVERRIDES_LABEL] = missingPackagesDependenciesFromOverrides;
      }

      return formatMissingStr(key, missingPackagesDependenciesOnFs, componentIssuesLabels[key]);
    }

    return formatMissingStr(key, missingComponent.issues[key], componentIssuesLabels[key]);
  }).join('');
  return `       ${missingStr}\n`;
}